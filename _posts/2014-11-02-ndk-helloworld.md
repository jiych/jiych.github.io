---
layout: post 
title: "smali方法调用指令"
description: ""
category: mobileApp
tags: []
---

今天实践了下ndk的简单使用，发现还是需要自己操作印象才深刻，借此记录下相关流程。这里所使用的ndk方式为直接使用java的jni，还有一种是使用android自己封装的一套（目前，还是有点傻傻分不清楚）。

我首先采用命令行创建了一个干净的android工程。

先简单看下`android create project`的使用：

`$ android create projec`

>       Usage:
       android [global options] create project [action options]
       Global options:
        -h --help       : Help on a specific command.
        -v --verbose    : Verbose mode, shows errors, warnings and all messages.
        --clear-cache: Clear the SDK Manager repository manifest cache.
        -s --silent     : Silent mode, shows errors only.

       Action "create project":
          Creates a new Android project.
          Options:
          -n --name          : Project name.
          -v --gradle-version: Gradle Android plugin version.
          -t --target        : Target ID of the new project. [required]
          -p --path          : The new project's directory. [required]
          -g --gradle        : Use gradle template.
          -k --package       : Android package name for the application. [required]
          -a --activity      : Name of the default Activity that is created.[required]
          
可以看到，只有几个参数是必须的，其中，

`-t`指定工程目标版本的ID，可以通过`android list target`查看；`-p`指定工程的目录；`-k`指定包名；`-a`指定主activity。

执行命令：

`$ android create project -t 1 -p testJni -k com.testJni -a Main`

可以看到命令执行完成后创建了一些目录及文件。

在`testJni/src/com/testJni/Main.java`中添加native方法，如

`public native int addfromJni(int a1, int a2)`

这里需要注意的是参数名称是必需的。并且添加加载动态库的代码，

`static { System.loadLibrary("testJni"); }`

在onCreate中添加测试代码，

`Log.e("testJni", "add_fromJni:"+addfromJni(1,3));`

随后进入`testJni`目录，利用`javah`指令生成`native`函数的相关声明。可以通过`javah -h`查看指令的使用帮助。

`javah [options] <classes>`

我只使用了下面两个参数，

`-d` 指定输出目录

`-classpath` 指定加载类文件的路径，如要生成`/path/testJni/src/com/testJni/Main.java`的jni头文件，则指定路径为`/path/testJni/src/`

`classes` 指定要生成类的全路径，如`com.testJni.Main`

执行命令：
`$ javah -d jni -classpath /path/testJni/src/ com.testJni.Main`

命令完成后将在当前目录下生成jni目录及com_testJni_Main.h头文件

`$ cat com_testJni_Main.h`

	/* DO NOT EDIT THIS FILE - it is machine generated */
	#include <jni.h>
	/* Header for class com_testJni_Main */

	#ifndef _Included_com_testJni_Main
	#define _Included_com_testJni_Main
	#ifdef __cplusplus
	extern "C" {
	#endif
	/*
	 * Class:     com_testJni_Main
	 * Method:    addfromJni
	 * Signature: (II)I
 	*/
	JNIEXPORT jint JNICALL Java_com_testJni_Main_addfromJni
  	(JNIEnv *, jobject, jint, jint);

	#ifdef __cplusplus
	}
	#endif
	#endif
	
创建文件com_testJni_Main.c文件，实现头文件中声明的native方法，内容如下：

	#include "com_testJni_Main.h"

	jint JNICALL Java_com_testJni_Main_addfromJni(JNIEnv *jenv, jobject jobj, jint a1, jint a2)
	{
  		return a1+a2;
	}

创建Android.mk及Application.mk，内容分别为

Android.mk:
	LOCAL_PATH := $(call my-dir)

	include $(CLEAR_VARS)

	LOCAL_MODULE := testJni
	LOCAL_SRC_FILES := com_testJni_Main.c
	include $(BUILD_SHARED_LIBRARY)
	
Application.mk:

	APP_ABI := x86
	
Application.mk文件是可选的，默认值为armeabi，由于我使用的是genymotion虚拟机，所以这里指定平台为x86的。

好了，在jni目录下执行`ndk-build`就可以生成相应的动态库了。

最后，在eclipse倒入testJni工程，编译运行，可以看到相应的log信息：

`$ adb logcat -s testJni`

`E/testJni ( 5439): add_fromJni:4`