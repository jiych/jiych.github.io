---
layout: post 
title: "OD学习之Canasta的逆向过程"
description: ""
category: security
tags: []
---

今天学习一个名为Canasta的crackme逆向分析，参看[这里](http://bbs.pediy.com/showthread.php?t=188552)。

##01 分析


在上面的链接中，作者已经给出了寻找正确序列号的方法，总结一下查找的过程是这样的。

* 查找模块中所用的名称及字符串信息，没有发现有价值的信息；
* 既然只有当输入的名称和序列号匹配时，OK按钮才会可用，可以猜测到在输入序列号信息时，程序进行了匹配；
* 输入部分序列号，再通过内存查找到输入的序列号，在对应的内存地址上设置访问断点；
* 设置断点后，继续输入序列号，则程序中断在前面设置的断点上，存放序列号的内存拷贝到了另一块内存；
* 在目的内存上面设置硬件访问断点，运行跟踪即可发现正确序列号。

---------
我在这里不光要找到正确的序列号，还要找到序列号的生成方法，并写出注册机的代码。

我猜想序列号应该是在输入注册名的时候就已经生成了，所以和上面一样，首先借由内存断点找到关键地方。

先输入部分注册名，在内存中查找已输入的注册名，找到后设置内存断点。运行再输入剩余注册名，程序断在了链接中已经指出的地方，即去黑名单中查找。
![image][1]

可以看到，查找“TNO”、“afdad”等黑名单时都是调用了函数004031B8，所以对于这些字符串的匹配及这个函数的调用，我们直接pass掉。

来到最后一个黑名单字符串处，可以看到一个新的函数调用004B3CFC。

![image][2]

在这里设置一个断点，经过数次运行分析发现这里确实是生成序列号的函数，下面分析这个函数的生成过程。

首先，需要注意几个存储空间的内容。

[ebp-118] 存放输入的注册名及长度信息

[ebp-10] 存放最终计算得到的序列号

[ebp-c] 存储目前已处理的字符数

其次，计算序列号的核心部分是一个嵌套的循环，如下：

![image][3]

分析这段代码，需要花点时间和耐心，总结一下这部分代码的功能：遍历注册名的每个字符，将每个字符与自己的index相乘，再与对应的魔数相乘，累积和，结果大于100万则停止，否则重复进行。


魔数如下：

![image][5]

##02 注册机代码

基于前面的分析，可以很容易写出对应的注册机。实现代码如下：

![image][6]


[1]:http://github-jiych.qiniudn.com/6633a01cc92e45c4a0bdb21004d369d9e02f010b-a88fa5d5e8a4e70582531b0344daeae9b0fec17b.png
[2]:http://github-jiych.qiniudn.com/899112f5221a9fb89377b894403f71c441efbd27-93b14022fee8b0bccc3467bbefd38863c5ce42b1.png
[3]:http://github-jiych.qiniudn.com/49eacbe60fc41ba6be220e07ebd10736115d65fb-cad24f46d713e059d750403a4dd9d706cae8d14a.png
[4]:http://github-jiych.qiniudn.com/923dedf0dbec719d96272c885d87ceb5a9bf951e-31e5e8b535ec7e2e712214951f074c2fc485e7e0.png
[5]:http://github-jiych.qiniudn.com/e9fff0b41c6e5a9386079182615a699236819271-31e5e8b535ec7e2e712214951f074c2fc485e7e0.png
[6]:http://github-jiych.qiniudn.com/8b6180209a01190bdd3d6febd9608ae5187192ce-0a4487c5262144cf0479705a71cf4edff26d85c7.png

