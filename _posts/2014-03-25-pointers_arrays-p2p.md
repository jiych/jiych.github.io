---
layout: post 
title: "指针数组与指向指针的指针"
description: ""
category: c
tags: []
---

曾经的公司爆发过一个问题，会导致用户的流量偶尔丢失，最后公司老大去向客户亲自道歉。问题出现的时机很随机，找不到任何导致出现的必然条件。最终问题还是被一点点复现了（可能花了测试人员加开发共4人7天的时间），问题的根源就是指针数组与二级指针混用所导致。我们习惯了下面的使用：

<pre><code>
char *s[] = {"hello", "world", "again"};
char **p = s;

int i = 0;
for(;i<sizeof(s)/sizeof(s[0]);i++, p++){
	printf("%s\n", *p);
}
</code></pre>

即使用二级指针来操作指针数组，这里由于每个指针数组的元素都是一个指针，所以这样的操作是没有问题的。但是如果将他们等同看待，那就是错误的了，如下：

------------
在文件a.c中定义g_val为一个指向整数类型的指针数组,而在b.h中申明g_var为一个二级指针。

a.c：

<code>
int g1,g2,g3;
int *g_var[] = {&g1, &g2, &g3};
</code>

b.h：

<code>
extern int **g_var;
</code>
------------

这个小小的错误编译器不会给出任何告警(包括lint也没有做出来)，却导致了28人天的代价。

假设g1,g2,g3恰好顺序排放,则在x86情况下，他们的地址正好依次加4，4正好是指针在x86机器上的字节大小。所以在这样的情况下，申明中所使用的`g_var+1`正好由起始时指向的g1地址再加上4，得到了g2地址，后面类似`g_var+2`可以得到g3的地址。

由于完全的巧合，这种申明和定义不完全一致的情况却能得到正确的结果。这导致了问题一直能够隐藏，而令这个问题后续难以复现的原因则是地址的随机分配，并且只是读取随机分配地址里存放的数值。这样由于起始地址是合法的，则基于此地址的小范围偏移基本上都是合法的，读取合法地址里的值自然不会有问题。

总结：

指针数组是表示一个数组，数组中的每一个元素都是一个指针；

指针的指针表示一个指针，指针所指向的内容为另一个指针。

指针的指针可以用来操作指针数组，但是不完全等同，申明与定义要保持完全的一致。
